MySQL :
    连接：
        left join  on 保留左表
        right join on 保留右表
        inner join on 保留交集

        -- 查询左右表所有的数据包括没有的 union 功能： 连接 + 去重 

            select *
                from class c left join student s on c.id = s.classid     //查询左表所有的
            UNION                  //连接查询结果 并去除重复
            select *
                from class c right join student s on c.id = s.classid    //查询右表所有的
            ;

        -- 左表独有

            select *
            from class c LEFT join student s on c.id = s.classid
            where s.id is null;         //除掉 包含右表的部分
    
    索引：
        索引就是一种数据结构，一种排好序的快速查询找的数据结构 
        平时的索引一般是 B树索引

        索引的优势：
            提高数据检索的效率，降低数据的IO成本，
            通过索引对数据进行排序，降低数据排序的成本，降低CPU消耗

        索引的劣势：
            虽然索引大大的提升了查询速度，同时会降低表的更新速度，如对表进行insert update delete 操作，因为更新表时，MYSQL不仅要保存数据
            还要保存一下索引文件每次更新台添加的索引字段。
        
        索引的分类：
            单值索引：一个索引只包含单个列，一个表可以有多个单列索引
        
        索引的命令：
            创建：create index/primary key/unique/fulltext  indexName on tableNmae(columnName(length),columnName(length) ...); length 可以省略
                  alter tableName add index/primary key/unique/fulltext indexName on columnName(length) length 可以省略
                                        普通/主键/唯一/全文
            删除：
                drop index indexName on tableName
            
            查看：
                show index from tableName
        
        索引结构：
            Btree,Hash,full-text,R-tree

            B-tree 检索原理-查看图片 mysql检索原理 

        哪些时候应该创建索引：
            1.主键 
            2.频繁作为查询条件的字段
            3.查询中与其他表关联的字段，外键关系建立索引
            4.高并发的条件下应该创建组合索引
            5.查询中排序的字段，通过索引访问将大大提高访问速度
            6.查询中统计或分组的字段
        
        那些时候部不应该创建索引：
            1.频繁更新的字段
            2.where 里用不到的字段
            3.表记录太少
            4.数据重复并且分布平均的表字段（差异不大的数据 e.g. 性别 只有两种状态）
        
        什么是覆盖索引：

            就是select的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。

            使用覆盖索引不要使用 * ，效率低下

            https://www.cnblogs.com/happyflyingpig/p/7662881.html
    
        MySQL性能分析：
            explain

            用法：
                explain + sql 语句
            e.g.
                explain select * from student;

            能干吗：
                表的读取顺序
                数据读索引的操作类型
                那些索引可以使用
                那些索引被实际使用
                表之间的引用
                每张表有多少行被优化器查询

            包含属性：
                 id  select_type  table  type  possible_keys  key   key_len  ref   rows  Extra 

                 id:查询顺序
                    select 查询的序列号，包含一组数字，表示查询中执行的select 子句或操作表的顺序
                    值：id 相同 （查询多个表时）
                            普通查询 ，查询顺序是一样的，由上到下执行
                        Id不相同：（查询多个表时）
                            如果是子查询，id 序列号会递增 ，id值越大越优先查询
                        id相同+不同：
                            一般是有一个虚表， from (select * ...) 这种情况下 虚表会认为是衍生表 table 属性是 derivcer id
                            id 如果相同，可以认为是一组，从上往下顺序执行，
                            id不同，id越大越先执行

                select_type: 查询类型
                    常用值：
                        simple,primary,subquery,derived,union,union result

                        simple: 简单的 select 查询 不包含子查询 或 union

                        primary: 查询中包含任何复杂的子查询，最外层标记为primary （如两表做UNION或者存在子查询的外层的表操作为PRIMARY，内层的操作为UNION）

                        subquery: select 或者 where 中包含子查询

                        derived:再from中包含的子查询（虚表 from (select * ...) ) 这种被标记为deriver,mysql会递归执行这些子查询，把结果放在临时表里

                        union：：若第二个select 出现在union中，则会被标记为union。若union包含再from子句的子查询中，外层select将标记为derived

                        union result:从union表获取结果的select 
                
                table： 表
                    来自那个表 有别名返回的就是别名
                
                type:     访问类型排序
                    显示查询使用的是那种类型
                    常用值：
                        all index range ref eq_ref const,system null

                    从最好到最差依次是  
                        
                        system > const > eq_ref > ref > range > index >all

                        system 表只有一行记录，也是const类型的特例

                        const 表示通过索引一次就查到了，const 用于比较primary key 或unique索引。因为只匹配一行数据，所以很快

                        eq_ref 唯一性索引扫描，对于每个索引，表中只有一条记录与之匹配。常用于主键或唯一索引 e.g. 员工表搜索ceo  id= 1这种只匹配一个

                    *   ref    非唯一索引扫描，返回匹配某个单独值得所有行。一般是复合索引  e.g. 员工表搜索保洁   job = "保洁" 匹配一堆

                    *   range 范围搜索，使用索引选择行，一般是where中使用between and,in 等

                        index 遍历全部得索引和树

                         all 全表扫描

                possible_keys：
                    此次查序可能用到得全部索引，不一定真的被用到
                
                key:
                    实际用到得索引

                    若查询中使用了覆盖索引，则该索引仅能出现在key 中
                    e.g.
                        create index c1_c2 on student(c1,c2);

                        select c1,c2 from student;

                        这里理论上 possible_keys什么都用不上，但是select 得 c1,c2 和索引 c1_c2 里得顺序一模一样，所以还是用了 索引
            
                key_len
                    索引中使用的字节数 长度越短越好
                
                ref:
                    显示索引得哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上得值
                    值：
                        const 常量
                        school.student.name    引用了school库 studnet 表 name 字段
                rows：
                    大致估算找到所需记录得行数
                
                Extra:
                    包含不适合再其他字段显示得信息
                    值：
                        using filesort ： 坏
                                mysql 会使用一个外部的索引排序，而不是按照表内索引进行读取

                        using temporary :  坏
                                使用了临时表保存数据 常见于 order by 和 group by    (group by ,order by 尽量按照所建索引个数顺序进行书写)        
                                e.g.
                                     create index index_c1_c2 on student(c1,c2);

                                     explain select c1 from student where c1 in ('ac','ab') group by c1 

                                        -> extra:  using filesort , using temporary , using index , using where 
                                    总结 ： 效率低下 索引和条件不一致
    
                                     explain select c1 from student where c1 in ('ac','ab') group by c1 , c2

                                        -> extra:  using index for group-by , using where 
                                    总结 ： 效率高效 索引和条件一致
                        
                        Using index : 好
                                表示select 中使用了覆盖索引，避免访问了表得数据行，效率不错!!!!如果同时出现using where ,表明索引被用来执行
                                索引键值得查找

                                覆盖索引：Covering index  查询列被索引覆盖，顺序内容完全一致，不需要读取数据得行
                        
                        using where :
                                使用了where 过滤
                        using join buffer :
                                使用了连接缓存
                        impossible where:
                                where 子句总是false ，不能用来获取任何元组
                                e.g.  select * from s where age  =11 and age = 100

        MySQL 索引优化:

            1.对于查询条件有范围得字段 不要加索引 ，索引会失效
                e.g. select name from student where age > 10 order by address;
                这里如果对 age 建立索引 expalin extra 里还是会显示 using filesort 没有用上索引
            
            2.双表查询时
                如果是  a left join b on a.id = b. id 这时索引要建立在 b.id 上，因为左连接 a表所有的都查询，所以进行筛选主要看b，右连接同理
                              






                    

                        

















































































