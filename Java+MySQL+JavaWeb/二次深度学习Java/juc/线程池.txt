优点：线程复用，控制最大并发数，管理线程  类似Spring控制对象池 可以提供最大得性能复用线程


          线程池7大参数  底层源码
          public ThreadPoolExecutor(int corePoolSize,    //线程池中常驻核心线程数
                  int maximumPoolSize,           //线程池最大线程数，此值必须大于1
                  long keepAliveTime,            //多余线程存活时间，线程池中线程超过corePoolSize ,存活时间超过 keepAliveTime ，多余线程会呗销毁
                  TimeUnit unit,               //keepAliveTime 的单位
                  BlockingQueue<Runnable> workQueue,    //任务队列，被提交没有被执行的队列
                  ThreadFactory threadFactory,           //线程池中的工作工厂，用于创建线程，可以缺省吗，即默认   就是品牌
                  RejectedExecutionHandler handler)   //拒绝策略 表示队列满了，并且工作线程大于等待线程的最大 线程数时如何拒绝请求执行的Runnable策略 可以缺省
        

ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(4, 5, 1L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>());


        for (int i=0;i<30;i++)
            //线程池使用 传入 Runnable
        poolExecutor.execute(()->{
            System.out.println("hahah         "+ Thread.currentThread().getName());
        });


        //线程池停止
        poolExecutor.shutdown();



    线程池扩容机制

        首先线程进来会到常驻线程中 corePoolSize 如果常驻线程满了，那就把再新增的线程送到阻塞队列 BlockingQueue 如果祖泽队列也满了，
        就开启备用线程，慢慢增加到线程池最大线程数 maxinumPoolSize 如果最大线程也满了，那么就开始劝退，拒绝策略开始起作用
    
    线程池的选择：

        根据阿里巴巴Java开发手册，Exectors创建的线程池都不能用，想用就自己手动创建（自定义的）：
            ExecutorService pool = Executors.newFixedThreadPool(10);   //一池固定数线程 自己设置
            ExecutorService pool2 = Executors.newSingleThreadExecutor();        //一池一个线程
            ExecutorService pool1 = Executors.newCachedThreadPool();        //一池N线程 根据需求动态变化

            Exectors返回的线程池的弊端：
            1：FixedThreadPool和SingleThradPool
                允许的队列请求长度为Integer.MAX_VALUE 可能会堆积大量的请求，导致OOM
            2：CacheThreadPol 和ScheduledThreadPool:
                允许创建的线程数量为Integer.MAX_VALUE ,可能会创建大量的线程，导致OOM
        











