

创建： 单例 原型 工厂 建造者
结构： 适配器 装饰器 享元 组合 代理
行为： 模板 策略 状态 责任链 观察者   


创建型模式：

    * 单例模式：singleton
        懒汉式 饿汉 线程安全式
    
    原型模式： protopype
        一个对象需要提供给其他对象访问，避免访问对象修改原来的值，就采用原型模式，克隆一份对象给访问者。
        实现 Cloneable接口，重写 clone方法，然后获取对象获取的就是克隆的，即使修改也不会影响到原来的值

    * 工厂模式：
        简单工厂： 适合只有两三个业务需求的模式
        工厂模式： 创造的都是一类产品对象，创建的较多if else的简单工厂不能满足使用工厂模式，定义一个总工厂接口然后不同的分工厂去实现接口
        抽象工厂模式： 使用抽象类或接口，擦黄造的产品是多种类型的，就是集合多种工厂于一身。总工厂为接口，各个分总工厂也是接口，比如手机总工厂
                      汽车总工厂，然后每一个分总工厂再去有不同的详细的实现，就是类 比如蓝色手机 红色手机，这样就是抽象工厂模式
    
    * 建造者模式：
        制造细节暴露给使用者 使用lombok @Builder可以实现

结构型模式:
    结构型模式关注的点是怎么组合对象/类
    分为两种模式
        1.类结构型模式：类和类的组合
        2.对象结构型模式： 类与对象的组合

    * 适配器模式（Adapter Pattern）
        是作为两个不兼容的接口之间的桥梁，适配器里有继承和组合两种模式
        适配器连接两个类，通过一个类增强另一个类，和装饰器区别在于加强的地方来自第三方（其他类）

        什么场景用到？
            Tomcat如何将Request流转为标准Request；
                tomcat.Request接口
                servlet.Request接口
                tomcat ===  CoyoteAdapte === ServletRequest
            Spring AOP中的AdvisorAdapter是什么：增强的适配器
                前置、后置、返回、结束  Advisor（通知方法）
                底层真的目标方法
            Spring MVC中经典的HandlerAdapter是什么；
                HelloController.hello()
                HandlerAdapter
                Servlet.doGet()
            SpringBoot 中 WebMvcConfigurerAdapter为什么存在又取消

    桥接模式 Bridge Pattern
        将抽象与实现解耦，
        e.g. 一个手机可以有多种售卖方式 线上 线下 抽奖等 还有不同品牌 小米 苹果 华为
            这属于两种维度的属性，现在把售卖方式 给抽取出来，每一种模式通过独立的类来表示


        实际应用：
            InputStreamReader 采用桥接 + 适配器模式

    * 装饰器模式 Decorator/Wrapper
        通过装饰器自己，增强一个类，加强的逻辑就写在装饰器的类里，剩下的原理同适配器

        什么场景使用？
        无处不在.....
        SpringSession中如何进行session与redis关联？HttpRequestWrapper
            session：数据存在了内存
            session：数据存在redis
            HttpSession；getAttribute();
            Wrapper(session){
            getAttribute(String param){    redis.get(param) };
            }
        MyBatisPlus提取了QueryWrapper，这是什么？
        Spring中的BeanWrapper是做什么？包装了Bean。bean的功能增强？
        Spring Webflux中的 WebHandlerDecorator？
        已存的类，每一天在某个功能使用的时候发现不够，就可以装饰器

    * 代理模式： Proxy

        jdk代理需要有接口 cglib不需要有接口
        静态代理：用法和装饰器完全一样，可以说装饰器是静态代理的一种，不过需要针对每一种代理对象创建一种代理类，很麻烦
        动态代理： 基于接口实现，通过接口，被代理对象和生成的代理对象实现相同的接口，来获取原对象的方法
        cglib代理：基于继承实现，通过继承获取被代理类的方法

        应用场景：

            MyBatis的mapper到底是什么？怎么生成的？
            动态代理
            UserMapper、CityMapper，mybatis帮我们写实现MapperProxy
            Alibaba Seata的DataSourceProxy是什么？
            DruidDataSource存在的Proxy模式

    * 组合模式：Composite
        把一组相似的对象当做单一的对象（自己存自己）
        是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次
        e.g. 电脑里的文件夹 一层套一层

        二叉树 每一个节点只保留自己的下级节点

    外观模式：Facade
        外观（Facade）模式又叫作门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式
        就是gateway 前端数据先打到网关再分化下去。

        什么场景使用？
            去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。以此类比......
            JAVA 的三层开发模式。
            分布式系统的网关
            Tomcat源码中的RequestFacade干什么的？

    * 享元模式 flyweight
        就是池技术，类似缓存池，线程池，再资源需要重复使用的情况下
        享元模式包含如下角色：
            抽象享元类
            具体享元类
            非共享具体享元类
            享元工厂类（简单工厂）




行为型模式：
    除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式
    关注怎么运行对象/类 怎么让他们跑起来
    分为对象行为模式，类行为模式

    * 模板模式 template 
        在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式模板。它的子类可以按需要重写方法实现，
        但调用将以抽象类中定义的方式进行。

        白话：模板定义了执行流程规范等架构，关键具体落地的实现需要子类实现模板自己去定义

        什么场景用到？
            Spring的整个继承体系都基本用到模板方法;
            BeanFactory.getBean(1,2,3,4)--A1---A2---A3---A4（全部被完成）
            JdbcTemplate、RedisTemplate都允许我们再扩展.....
            我们自己的系统也应该使用模板方法组织类结构

   * 策略（Strategy）模式
        策略（Strategy）模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。属于对象行为模式。

        白话： 策略模式就是通过一个接口有多个策略实现类，在吧这个接口注入到对应的需要这个策略的类里去应用。
        e.g.
                游戏类： 
                        连接游戏策略接口，通过构造器传入不同的策略模式，来获取游戏的胜利

        什么场景用到？
            使用策略模式可以避免使用多重条件语句，如 if...else 语句、switch...case 语句
            什么是Spring的 InstantiationStrategy
            线程池拒绝策略

  *  状态（State）模式
        状态（State）模式：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。

        状态模式类似于策略模式，不同之处在于，策略模式的不同策略不会产生不同的状态，而状态模式的不同策略会产生不同的状态

        e.g.
            游戏类：
                    传入不同的策略，可能会输可能会赢可能会不打游戏


    中介者（Mediator）模式

        用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，减少对象间混乱的依赖关系，从而使其耦合松散，
        而且可以独立地改变它们之间的交互。对象行为型模式。


        什么场景用到？
            SpringMVC 的 DispatcherServlet是一个中介者，他会提取Controller、Model、View来进行调用。而无需controller直接调用view之类的渲染方法
            分布式系统中的网关
            迪米特法则的一个典型应用
            中介者和外观（门面）模式区别？
            中介者双向操作，门面偏向于封装某一方


  ·*  观察者（Observer）模式

        观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知
        被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）
        模式或从属者（Dependents）模式。对象行为型模式

        e.g. MQ vue双向渲染


    备忘录（Memento）模式
        备忘录（Memento）模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对
        象恢复到原先保存的状态。该模式又叫快照模式。对象行为型模式
        
        e.g. 游戏存档
             数据库
             git 

    解释器（Interpreter）模式
        解释器（Interpreter）模式：给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，
        用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。类行为型模式

        白话：自己定义一个 类似的正则规则解析器


    命令（Command）模式
        命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，
        这样方便将命令对象进行储存、传递、调用、增加与管理

        什么场景用到？
            mvc就是典型的命令模式
            当系统需要执行一组操作时，命令模式可以定义宏命令（一个命令组合了多个命令）来实现该功能。
            结合备忘录模式还可以实现命令的撤销和恢复



    迭代器（Iterator）模式
        迭代器（Iterator）模式：提供一个对象(迭代器)来顺序访问聚合对象(迭代数据)中的一系列数据，而不暴露聚合对象的内部表示。
        对象行为型模式

        访问数据通过自定义的 next() first() hasNext() 这种位移来获取


    访问者（Visitor）模式
        访问者（Visitor）模式：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以
        添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模
        式中最复杂的一种模式

  *  职责链（Chain of Responsibility）模式
        责任链（Chain of Responsibility）模式：为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一
        对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。属于对象行为型模式

        典型的链表结构 顺着链表一直走下去

        什么场景用到？
            Tomcat的Pipeline、Valve
            Filter链
            Aop责任链































   